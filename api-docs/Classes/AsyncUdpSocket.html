<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>AsyncUdpSocket Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">iHealthSDKStatic </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">iHealth</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	

	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/bindToAddress:port:error:">- bindToAddress:port:error:</option>
		
		<option value="//api/name/bindToPort:error:">- bindToPort:error:</option>
		
		<option value="//api/name/close">- close</option>
		
		<option value="//api/name/closeAfterReceiving">- closeAfterReceiving</option>
		
		<option value="//api/name/closeAfterSending">- closeAfterSending</option>
		
		<option value="//api/name/closeAfterSendingAndReceiving">- closeAfterSendingAndReceiving</option>
		
		<option value="//api/name/connectToAddress:error:">- connectToAddress:error:</option>
		
		<option value="//api/name/connectToHost:onPort:error:">- connectToHost:onPort:error:</option>
		
		<option value="//api/name/connectedHost">- connectedHost</option>
		
		<option value="//api/name/convertForBindHost:port:intoAddress4:address6:">- convertForBindHost:port:intoAddress4:address6:</option>
		
		<option value="//api/name/convertForSendHost:port:intoAddress4:address6:">- convertForSendHost:port:intoAddress4:address6:</option>
		
		<option value="//api/name/doSend:">- doSend:</option>
		
		<option value="//api/name/enableBroadcast:error:">- enableBroadcast:error:</option>
		
		<option value="//api/name/endCurrentSend">- endCurrentSend</option>
		
		<option value="//api/name/getErrnoError">- getErrnoError</option>
		
		<option value="//api/name/getSocketError">- getSocketError</option>
		
		<option value="//api/name/init">- init</option>
		
		<option value="//api/name/initIPv4">- initIPv4</option>
		
		<option value="//api/name/isClosed">- isClosed</option>
		
		<option value="//api/name/isConnected">- isConnected</option>
		
		<option value="//api/name/isIPv4">- isIPv4</option>
		
		<option value="//api/name/isIPv6">- isIPv6</option>
		
		<option value="//api/name/joinMulticastGroup:error:">- joinMulticastGroup:error:</option>
		
		<option value="//api/name/localHost">- localHost</option>
		
		<option value="//api/name/maxReceiveBufferSize">- maxReceiveBufferSize</option>
		
		<option value="//api/name/maximumTransmissionUnit">- maximumTransmissionUnit</option>
		
		<option value="//api/name/maybeDequeueReceive">- maybeDequeueReceive</option>
		
		<option value="//api/name/maybeDequeueSend">- maybeDequeueSend</option>
		
		<option value="//api/name/moveToRunLoop:">- moveToRunLoop:</option>
		
		<option value="//api/name/receiveWithTimeout:tag:">- receiveWithTimeout:tag:</option>
		
		<option value="//api/name/runLoopModes">- runLoopModes</option>
		
		<option value="//api/name/scheduleDequeueReceive">- scheduleDequeueReceive</option>
		
		<option value="//api/name/scheduleDequeueSend">- scheduleDequeueSend</option>
		
		<option value="//api/name/sendData:toAddress:withTimeout:tag:">- sendData:toAddress:withTimeout:tag:</option>
		
		<option value="//api/name/sendData:toHost:port:withTimeout:tag:">- sendData:toHost:port:withTimeout:tag:</option>
		
		<option value="//api/name/sendData:withTimeout:tag:">- sendData:withTimeout:tag:</option>
		
		<option value="//api/name/setRunLoopModes:">- setRunLoopModes:</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">AsyncUdpSocket Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>AsyncUdpSocket.h<br />AsyncUdpSocket.m</td>
</tr>
						</tbody></table></div>
					

                    

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="method-title"><code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates new instances of AsyncUdpSocket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (id)init</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/initIPv4" title="initIPv4"></a>
	<h3 class="method-title"><code><a href="#//api/name/initIPv4">&ndash;&nbsp;initIPv4</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates new instances of AsyncUdpSocket that support only IPv4 or IPv6.
The other <a href="#//api/name/init">init</a> methods will support both, unless specifically binded or connected to one protocol.
If you know you&rsquo;ll only be using one protocol, these <a href="#//api/name/init">init</a> methods may be a bit more efficient.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (id)initIPv4</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/localHost" title="localHost"></a>
	<h3 class="method-title"><code><a href="#//api/name/localHost">&ndash;&nbsp;localHost</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the local address info for the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSString *)localHost</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Note: Address info may not be available until after the socket has been bind'ed,
or until after data has been sent.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectedHost" title="connectedHost"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectedHost">&ndash;&nbsp;connectedHost</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the remote address info for the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSString *)connectedHost</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Note: Since UDP is connectionless by design, connected address info
will not be available unless the socket is explicitly connected to a remote host/port</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isConnected" title="isConnected"></a>
	<h3 class="method-title"><code><a href="#//api/name/isConnected">&ndash;&nbsp;isConnected</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isConnected</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isClosed" title="isClosed"></a>
	<h3 class="method-title"><code><a href="#//api/name/isClosed">&ndash;&nbsp;isClosed</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isClosed</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket supports IPv4.
By default this will be true, unless the socket is specifically initialized as IPv6 only,
or is binded or connected to an IPv6 address.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv6" title="isIPv6"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv6">&ndash;&nbsp;isIPv6</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket supports IPv6.
By default this will be true, unless the socket is specifically initialized as IPv4 only,
or is binded or connected to an IPv4 address.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method will also return false on platforms that do not support IPv6.
Note: The iPhone does not currently support IPv6.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maximumTransmissionUnit" title="maximumTransmissionUnit"></a>
	<h3 class="method-title"><code><a href="#//api/name/maximumTransmissionUnit">&ndash;&nbsp;maximumTransmissionUnit</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the mtu of the socket.
If unknown, returns zero.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (unsigned int)maximumTransmissionUnit</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Sending data larger than this may result in an error.
This is an advanced topic, and one should understand the wide range of mtu&rsquo;s on networks and the internet.
Therefore this method is only for reference and may be of little use in many situations.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bindToPort:error:" title="bindToPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/bindToPort:error:">&ndash;&nbsp;bindToPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Binds the UDP socket to the given port and optional address.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bindToAddress:port:error:" title="bindToAddress:port:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/bindToAddress:port:error:">&ndash;&nbsp;bindToAddress:port:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Binds the underlying socket(s) to the given address and port.
The sockets(s) will be able to receive data only on the given interface.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)bindToAddress:(NSString *)<em>host</em> port:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>To receive data on any interface, pass nil or &ldquo;&rdquo;.
To receive data only on the loopback interface, pass &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo;.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Choosing to connect to a specific host/port has the following effect:
- You will only be able to send data to the connected host/port.
- You will only be able to receive data from the connected host/port.
- You will receive ICMP messages that come from the connected host/port, such as &ldquo;connection refused&rdquo;.</p>

<p>Connecting a UDP socket does not result in any communication on the socket.
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after its been connected.
You can only connect a socket once.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects the underlying UDP socket to the remote address.
If the address is an IPv4 address, the IPv4 socket is connected, and the IPv6 socket is invalidated and released.
If the address is an IPv6 address, the IPv6 socket is connected, and the IPv4 socket is invalidated and released.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>The address is a native address structure, as may be returned from API&rsquo;s such as Bonjour.
An address may be created manually by simply wrapping a sockaddr_in or sockaddr_in6 in an NSData object.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/joinMulticastGroup:error:" title="joinMulticastGroup:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/joinMulticastGroup:error:">&ndash;&nbsp;joinMulticastGroup:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Join multicast group</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;)</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/enableBroadcast:error:" title="enableBroadcast:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/enableBroadcast:error:">&ndash;&nbsp;enableBroadcast:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>By default, the underlying socket in the OS will not allow you to send broadcast messages.
In order to send broadcast messages, you need to enable this functionality in the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)enableBroadcast:(BOOL)<em>flag</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>A broadcast is a UDP message to addresses like &ldquo;192.168.255.255&rdquo; or &ldquo;255.255.255.255&rdquo; that is
delivered to every host on the network.
The reason this is generally disabled by default is to prevent
accidental broadcast messages from flooding the network.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:withTimeout:tag:" title="sendData:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:withTimeout:tag:">&ndash;&nbsp;sendData:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)sendData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method may only be used with a connected socket.</p>

<p>If data is nil or zero-length, this method does nothing and immediately returns NO.
If the socket is not connected, this method does nothing and immediately returns NO.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:toHost:port:withTimeout:tag:" title="sendData:toHost:port:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:toHost:port:withTimeout:tag:">&ndash;&nbsp;sendData:toHost:port:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)sendData:(NSData *)<em>data</em> toHost:(NSString *)<em>host</em> port:(UInt16)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method cannot be used with a connected socket.</p>

<p>If data is nil or zero-length, this method does nothing and immediately returns NO.
If the socket is connected, this method does nothing and immediately returns NO.
If unable to resolve host to a valid IPv4 or IPv6 address, this method returns NO.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:toAddress:withTimeout:tag:" title="sendData:toAddress:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:toAddress:withTimeout:tag:">&ndash;&nbsp;sendData:toAddress:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)sendData:(NSData *)<em>data</em> toAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method cannot be used with a connected socket.</p>

<p>If data is nil or zero-length, this method does nothing and immediately returns NO.
If the socket is connected, this method does nothing and immediately returns NO.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/receiveWithTimeout:tag:" title="receiveWithTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/receiveWithTimeout:tag:">&ndash;&nbsp;receiveWithTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously receives a single datagram packet.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)receiveWithTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>If the receive succeeds, the onUdpSocket:didReceiveData:fromHost:port:tag delegate method will be called.
Otherwise, a timeout will occur, and the onUdpSocket:didNotReceiveDataWithTag: delegate method will be called.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/close" title="close"></a>
	<h3 class="method-title"><code><a href="#//api/name/close">&ndash;&nbsp;close</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Closes the socket immediately. Any pending send or receive operations are dropped.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)close</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/closeAfterSending" title="closeAfterSending"></a>
	<h3 class="method-title"><code><a href="#//api/name/closeAfterSending">&ndash;&nbsp;closeAfterSending</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Closes after all pending send operations have completed.
After calling this, the sendData: and receive: methods will do nothing.
In other words, you won&rsquo;t be able to add any more send or receive operations to the queue.
The socket will <a href="#//api/name/close">close</a> even if there are still pending receive operations.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)closeAfterSending</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/closeAfterReceiving" title="closeAfterReceiving"></a>
	<h3 class="method-title"><code><a href="#//api/name/closeAfterReceiving">&ndash;&nbsp;closeAfterReceiving</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Closes after all pending receive operations have completed.
After calling this, the sendData: and receive: methods will do nothing.
In other words, you won&rsquo;t be able to add any more send or receive operations to the queue.
The socket will <a href="#//api/name/close">close</a> even if there are still pending send operations.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)closeAfterReceiving</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/closeAfterSendingAndReceiving" title="closeAfterSendingAndReceiving"></a>
	<h3 class="method-title"><code><a href="#//api/name/closeAfterSendingAndReceiving">&ndash;&nbsp;closeAfterSendingAndReceiving</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Closes after all pending send and receive operations have completed.
After calling this, the sendData: and receive: methods will do nothing.
In other words, you won&rsquo;t be able to add any more send or receive operations to the queue.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)closeAfterSendingAndReceiving</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maxReceiveBufferSize" title="maxReceiveBufferSize"></a>
	<h3 class="method-title"><code><a href="#//api/name/maxReceiveBufferSize">&ndash;&nbsp;maxReceiveBufferSize</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default size is 9216 bytes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (UInt32)maxReceiveBufferSize</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.
The theoretical maximum size of any IPv6 UDP packet is UINT32_MAX = 4294967295.</p>

<p>In practice, however, the size of UDP packets will be much smaller.
Indeed most protocols will send and receive packets of only a few bytes,
or will set a limit on the size of packets to prevent fragmentation in the IP layer.</p>

<p>If you set the buffer size too small, the sockets API in the OS will silently discard
any extra data, and you will not be notified of the error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/moveToRunLoop:" title="moveToRunLoop:"></a>
	<h3 class="method-title"><code><a href="#//api/name/moveToRunLoop:">&ndash;&nbsp;moveToRunLoop:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>When you create an AsyncUdpSocket, it is added to the runloop of the current thread.
So it is easiest to simply create the socket on the thread you intend to use it.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)moveToRunLoop:(NSRunLoop *)<em>runLoop</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>If, however, you need to move the socket to a separate thread at a later time, this
method may be used to accomplish the task.</p>

<p>This method must be called from the thread/runloop the socket is currently running on.</p>

<p>Note: After calling this method, all further method calls to this object should be done from the given runloop.
Also, all delegate calls will be sent on the given runloop.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setRunLoopModes:" title="setRunLoopModes:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setRunLoopModes:">&ndash;&nbsp;setRunLoopModes:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows you to configure which run loop modes the socket uses.
The default set of run loop modes is NSDefaultRunLoopMode.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)setRunLoopModes:(NSArray *)<em>runLoopModes</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>If you&rsquo;d like your socket to continue operation during other modes, you may want to add modes such as
NSModalPanelRunLoopMode or NSEventTrackingRunLoopMode. Or you may simply want to use NSRunLoopCommonModes.</p>

<p>Note: NSRunLoopCommonModes is defined in 10.5. For previous versions one can use kCFRunLoopCommonModes.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/runLoopModes" title="runLoopModes"></a>
	<h3 class="method-title"><code><a href="#//api/name/runLoopModes">&ndash;&nbsp;runLoopModes</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the current run loop modes the <a href="../Classes/AsyncSocket.html">AsyncSocket</a> instance is operating in.
The default set of run loop modes is NSDefaultRunLoopMode.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSArray *)runLoopModes</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/convertForBindHost:port:intoAddress4:address6:" title="convertForBindHost:port:intoAddress4:address6:"></a>
	<h3 class="method-title"><code><a href="#//api/name/convertForBindHost:port:intoAddress4:address6:">&ndash;&nbsp;convertForBindHost:port:intoAddress4:address6:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Attempts to convert the given host/port into and IPv4 and/or IPv6 data structure.
The data structure is of type sockaddr_in for IPv4 and sockaddr_in6 for IPv6.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (int)convertForBindHost:(NSString *)<em>host</em> port:(UInt16)<em>port</em> intoAddress4:(NSData **)<em>address4</em> address6:(NSData **)<em>address6</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns zero on success, or one of the error codes listed in gai_strerror if an error occurs (as per getaddrinfo).</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/convertForSendHost:port:intoAddress4:address6:" title="convertForSendHost:port:intoAddress4:address6:"></a>
	<h3 class="method-title"><code><a href="#//api/name/convertForSendHost:port:intoAddress4:address6:">&ndash;&nbsp;convertForSendHost:port:intoAddress4:address6:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Attempts to convert the given host/port into and IPv4 and/or IPv6 data structure.
The data structure is of type sockaddr_in for IPv4 and sockaddr_in6 for IPv6.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (int)convertForSendHost:(NSString *)<em>host</em> port:(UInt16)<em>port</em> intoAddress4:(NSData **)<em>address4</em> address6:(NSData **)<em>address6</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns zero on success, or one of the error codes listed in gai_strerror if an error occurs (as per getaddrinfo).</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getErrnoError" title="getErrnoError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getErrnoError">&ndash;&nbsp;getErrnoError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard error object for the current errno value.
Errno is used for low-level BSD socket errors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getErrnoError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getSocketError" title="getSocketError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getSocketError">&ndash;&nbsp;getSocketError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard error message for a CFSocket error.
Unfortunately, CFSocket offers no feedback on its errors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getSocketError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/scheduleDequeueSend" title="scheduleDequeueSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/scheduleDequeueSend">&ndash;&nbsp;scheduleDequeueSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Puts a <a href="#//api/name/maybeDequeueSend">maybeDequeueSend</a> on the run loop.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)scheduleDequeueSend</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeDequeueSend" title="maybeDequeueSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeDequeueSend">&ndash;&nbsp;maybeDequeueSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method starts a new send, if needed.
It is called when a user requests a send.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeDequeueSend</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doSend:" title="doSend:"></a>
	<h3 class="method-title"><code><a href="#//api/name/doSend:">&ndash;&nbsp;doSend:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is called when a new read is taken from the read queue or when new data becomes available on the stream.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doSend:(CFSocketRef)<em>theSocket</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/endCurrentSend" title="endCurrentSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/endCurrentSend">&ndash;&nbsp;endCurrentSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Ends the current send, and all associated variables such as the send timer.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)endCurrentSend</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/scheduleDequeueReceive" title="scheduleDequeueReceive"></a>
	<h3 class="method-title"><code><a href="#//api/name/scheduleDequeueReceive">&ndash;&nbsp;scheduleDequeueReceive</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Puts a <a href="#//api/name/maybeDequeueReceive">maybeDequeueReceive</a> on the run loop.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)scheduleDequeueReceive</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeDequeueReceive" title="maybeDequeueReceive"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeDequeueReceive">&ndash;&nbsp;maybeDequeueReceive</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Starts a new receive operation if needed</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeDequeueReceive</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2017 iHealth. All rights reserved. Updated: 2017-05-05</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>