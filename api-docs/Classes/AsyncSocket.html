<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>AsyncSocket Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">iHealthSDKStatic </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">iHealth</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	

	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/acceptOnAddress:port:error:">- acceptOnAddress:port:error:</option>
		
		<option value="//api/name/attachSocketsToRunLoop:error:">- attachSocketsToRunLoop:error:</option>
		
		<option value="//api/name/close">- close</option>
		
		<option value="//api/name/configureSocketAndReturnError:">- configureSocketAndReturnError:</option>
		
		<option value="//api/name/configureStreamsAndReturnError:">- configureStreamsAndReturnError:</option>
		
		<option value="//api/name/connectToAddress:withTimeout:error:">- connectToAddress:withTimeout:error:</option>
		
		<option value="//api/name/connectToHost:onPort:withTimeout:error:">- connectToHost:onPort:withTimeout:error:</option>
		
		<option value="//api/name/createAcceptSocketForAddress:error:">- createAcceptSocketForAddress:error:</option>
		
		<option value="//api/name/createStreamsFromNative:error:">- createStreamsFromNative:error:</option>
		
		<option value="//api/name/createStreamsToHost:onPort:error:">- createStreamsToHost:onPort:error:</option>
		
		<option value="//api/name/disconnect">- disconnect</option>
		
		<option value="//api/name/disconnectAfterReading">- disconnectAfterReading</option>
		
		<option value="//api/name/disconnectAfterReadingAndWriting">- disconnectAfterReadingAndWriting</option>
		
		<option value="//api/name/disconnectAfterWriting">- disconnectAfterWriting</option>
		
		<option value="//api/name/doAcceptWithSocket:">- doAcceptWithSocket:</option>
		
		<option value="//api/name/doBytesAvailable">- doBytesAvailable</option>
		
		<option value="//api/name/doSocketOpen:withCFSocketError:">- doSocketOpen:withCFSocketError:</option>
		
		<option value="//api/name/doStreamOpen">- doStreamOpen</option>
		
		<option value="//api/name/enablePreBuffering">- enablePreBuffering</option>
		
		<option value="//api/name/getAbortError">- getAbortError</option>
		
		<option value="//api/name/getConnectTimeoutError">- getConnectTimeoutError</option>
		
		<option value="//api/name/getErrnoError">- getErrnoError</option>
		
		<option value="//api/name/getReadMaxedOutError">- getReadMaxedOutError</option>
		
		<option value="//api/name/getReadTimeoutError">- getReadTimeoutError</option>
		
		<option value="//api/name/getSocketError">- getSocketError</option>
		
		<option value="//api/name/getWriteTimeoutError">- getWriteTimeoutError</option>
		
		<option value="//api/name/hasBytesAvailable">- hasBytesAvailable</option>
		
		<option value="//api/name/maybeDequeueRead">- maybeDequeueRead</option>
		
		<option value="//api/name/maybeScheduleDisconnect">- maybeScheduleDisconnect</option>
		
		<option value="//api/name/moveToRunLoop:">- moveToRunLoop:</option>
		
		<option value="//api/name/readIntoBuffer:maxLength:">- readIntoBuffer:maxLength:</option>
		
		<option value="//api/name/scheduleDequeueRead">- scheduleDequeueRead</option>
		
		<option value="//api/name/setRunLoopModes:">- setRunLoopModes:</option>
		
		<option value="//api/name/unreadData">- unreadData</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">AsyncSocket Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>AsyncSocket.h<br />AsyncSocket.m</td>
</tr>
						</tbody></table></div>
					

                    

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/acceptOnAddress:port:error:" title="acceptOnAddress:port:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/acceptOnAddress:port:error:">&ndash;&nbsp;acceptOnAddress:port:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>To accept on a certain address, pass the address to accept on.
To accept on any address, pass nil or an empty string.
To accept only connections from localhost pass &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo;.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnAddress:(NSString *)<em>hostaddr</em> port:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToHost:onPort:withTimeout:error:" title="connectToHost:onPort:withTimeout:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToHost:onPort:withTimeout:error:">&ndash;&nbsp;connectToHost:onPort:withTimeout:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method creates an initial CFReadStream and CFWriteStream to the given host on the given port.
The connection is then opened, and the corresponding CFSocket will be extracted after the connection succeeds.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Thus the delegate will have access to the CFReadStream and CFWriteStream prior to connection,
specifically in the onSocketWillConnect: method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:withTimeout:error:" title="connectToAddress:withTimeout:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:withTimeout:error:">&ndash;&nbsp;connectToAddress:withTimeout:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method creates an initial CFSocket to the given address.
The connection is then opened, and the corresponding CFReadStream and CFWriteStream will be
created from the low-level sockets after the connection succeeds.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Thus the delegate will have access to the CFSocket and CFSocketNativeHandle (BSD socket) prior to connection,
specifically in the onSocketWillConnect: method.</p>

<p>Note: The NSData parameter is expected to be a sockaddr structure. For example, an NSData object returned from
NSNetservice addresses method.
If you have an existing struct sockaddr you can convert it to an NSData object like so:
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnect" title="disconnect"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnect">&ndash;&nbsp;disconnect</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects immediately. Any pending reads or writes are dropped.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnect</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterReading" title="disconnectAfterReading"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterReading">&ndash;&nbsp;disconnectAfterReading</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Diconnects after all pending reads have completed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReading</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterWriting" title="disconnectAfterWriting"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterWriting">&ndash;&nbsp;disconnectAfterWriting</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects after all pending writes have completed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterWriting</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterReadingAndWriting" title="disconnectAfterReadingAndWriting"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterReadingAndWriting">&ndash;&nbsp;disconnectAfterReadingAndWriting</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects after all pending reads and writes have completed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReadingAndWriting</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/enablePreBuffering" title="enablePreBuffering"></a>
	<h3 class="method-title"><code><a href="#//api/name/enablePreBuffering">&ndash;&nbsp;enablePreBuffering</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>See the header file for a full explanation of pre-buffering.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)enablePreBuffering</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/moveToRunLoop:" title="moveToRunLoop:"></a>
	<h3 class="method-title"><code><a href="#//api/name/moveToRunLoop:">&ndash;&nbsp;moveToRunLoop:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>See the header file for a full explanation of this method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)moveToRunLoop:(NSRunLoop *)<em>runLoop</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setRunLoopModes:" title="setRunLoopModes:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setRunLoopModes:">&ndash;&nbsp;setRunLoopModes:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>See the header file for a full explanation of this method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)setRunLoopModes:(NSArray *)<em>runLoopModes</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/unreadData" title="unreadData"></a>
	<h3 class="method-title"><code><a href="#//api/name/unreadData">&ndash;&nbsp;unreadData</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read
any data that&rsquo;s left on the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSData *)unreadData</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/createAcceptSocketForAddress:error:" title="createAcceptSocketForAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createAcceptSocketForAddress:error:">&ndash;&nbsp;createAcceptSocketForAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the accept sockets.
Returns true if either IPv4 or IPv6 is created.
If either is missing, an error is returned (even though the method may return true).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (CFSocketRef)createAcceptSocketForAddress:(NSData *)<em>addr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/attachSocketsToRunLoop:error:" title="attachSocketsToRunLoop:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/attachSocketsToRunLoop:error:">&ndash;&nbsp;attachSocketsToRunLoop:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Adds the CFSocket&rsquo;s to the run-loop so that callbacks will work properly.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)attachSocketsToRunLoop:(NSRunLoop *)<em>runLoop</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/configureSocketAndReturnError:" title="configureSocketAndReturnError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/configureSocketAndReturnError:">&ndash;&nbsp;configureSocketAndReturnError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows the delegate method to configure the CFSocket or CFNativeSocket as desired before we connect.
Note that the CFReadStream and CFWriteStream will not be available until after the connection is opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)configureSocketAndReturnError:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doAcceptWithSocket:" title="doAcceptWithSocket:"></a>
	<h3 class="method-title"><code><a href="#//api/name/doAcceptWithSocket:">&ndash;&nbsp;doAcceptWithSocket:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Attempt to make the new socket.
If an error occurs, ignore this event.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doAcceptWithSocket:(CFSocketNativeHandle)<em>newNative</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doSocketOpen:withCFSocketError:" title="doSocketOpen:withCFSocketError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/doSocketOpen:withCFSocketError:">&ndash;&nbsp;doSocketOpen:withCFSocketError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Description forthcoming&hellip;</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doSocketOpen:(CFSocketRef)<em>sock</em> withCFSocketError:(CFSocketError)<em>socketError</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/createStreamsFromNative:error:" title="createStreamsFromNative:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createStreamsFromNative:error:">&ndash;&nbsp;createStreamsFromNative:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the CFReadStream and CFWriteStream from the given native socket.
The CFSocket may be extracted from either stream after the streams have been opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)createStreamsFromNative:(CFSocketNativeHandle)<em>native</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Note: The given native socket must already be connected!</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/createStreamsToHost:onPort:error:" title="createStreamsToHost:onPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createStreamsToHost:onPort:error:">&ndash;&nbsp;createStreamsToHost:onPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the CFReadStream and CFWriteStream from the given hostname and port number.
The CFSocket may be extracted from either stream after the streams have been opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)createStreamsToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/configureStreamsAndReturnError:" title="configureStreamsAndReturnError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/configureStreamsAndReturnError:">&ndash;&nbsp;configureStreamsAndReturnError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows the delegate method to configure the CFReadStream and/or CFWriteStream as desired before we connect.
Note that the CFSocket and CFNativeSocket will not be available until after the connection is opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)configureStreamsAndReturnError:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doStreamOpen" title="doStreamOpen"></a>
	<h3 class="method-title"><code><a href="#//api/name/doStreamOpen">&ndash;&nbsp;doStreamOpen</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Called when read or write streams open.
When the socket is connected and both streams are open, consider the AsyncSocket instance to be ready.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doStreamOpen</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/close" title="close"></a>
	<h3 class="method-title"><code><a href="#//api/name/close">&ndash;&nbsp;close</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects. This is called for both error and clean disconnections.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)close</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeScheduleDisconnect" title="maybeScheduleDisconnect"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeScheduleDisconnect">&ndash;&nbsp;maybeScheduleDisconnect</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Schedules a call to <a href="#//api/name/disconnect">disconnect</a> if possible.
That is, if all writes have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after writing,
or if all reads have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after reading.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeScheduleDisconnect</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getErrnoError" title="getErrnoError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getErrnoError">&ndash;&nbsp;getErrnoError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard error object for the current errno value.
Errno is used for low-level BSD socket errors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getErrnoError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getSocketError" title="getSocketError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getSocketError">&ndash;&nbsp;getSocketError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard error message for a CFSocket error.
Unfortunately, CFSocket offers no feedback on its errors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getSocketError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getAbortError" title="getAbortError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getAbortError">&ndash;&nbsp;getAbortError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket abort error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getAbortError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getConnectTimeoutError" title="getConnectTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getConnectTimeoutError">&ndash;&nbsp;getConnectTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket connect timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getConnectTimeoutError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getReadMaxedOutError" title="getReadMaxedOutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getReadMaxedOutError">&ndash;&nbsp;getReadMaxedOutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket maxed out error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getReadMaxedOutError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getReadTimeoutError" title="getReadTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getReadTimeoutError">&ndash;&nbsp;getReadTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket read timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getReadTimeoutError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getWriteTimeoutError" title="getWriteTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getWriteTimeoutError">&ndash;&nbsp;getWriteTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket write timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getWriteTimeoutError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/scheduleDequeueRead" title="scheduleDequeueRead"></a>
	<h3 class="method-title"><code><a href="#//api/name/scheduleDequeueRead">&ndash;&nbsp;scheduleDequeueRead</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Puts a <a href="#//api/name/maybeDequeueRead">maybeDequeueRead</a> on the run loop.
An assumption here is that selectors will be performed consecutively within their priority.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)scheduleDequeueRead</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeDequeueRead" title="maybeDequeueRead"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeDequeueRead">&ndash;&nbsp;maybeDequeueRead</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method starts a new read, if needed.
It is called when a user requests a read,
or when a stream opens that may have requested reads sitting in the queue, etc.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeDequeueRead</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/hasBytesAvailable" title="hasBytesAvailable"></a>
	<h3 class="method-title"><code><a href="#//api/name/hasBytesAvailable">&ndash;&nbsp;hasBytesAvailable</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamHasBytesAvailable().
This method supports pre-buffering properly.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)hasBytesAvailable</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readIntoBuffer:maxLength:" title="readIntoBuffer:maxLength:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readIntoBuffer:maxLength:">&ndash;&nbsp;readIntoBuffer:maxLength:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamRead().
This method support pre-buffering properly.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (CFIndex)readIntoBuffer:(UInt8 *)<em>buffer</em> maxLength:(CFIndex)<em>length</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doBytesAvailable" title="doBytesAvailable"></a>
	<h3 class="method-title"><code><a href="#//api/name/doBytesAvailable">&ndash;&nbsp;doBytesAvailable</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is called when a new read is taken from the read queue or when new data becomes available on the stream.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doBytesAvailable</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2017 iHealth. All rights reserved. Updated: 2017-05-05</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>