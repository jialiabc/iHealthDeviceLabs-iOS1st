<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>GCDAsyncUdpSocket Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">iHealthSDKStatic </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">iHealth</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	

	
	<optgroup label="Class Methods">
		
		<option value="//api/name/hostFromAddress:">+ hostFromAddress:</option>
		
	</optgroup>
	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/asyncResolveHost:port:withCompletionBlock:">- asyncResolveHost:port:withCompletionBlock:</option>
		
		<option value="//api/name/bindToAddress:error:">- bindToAddress:error:</option>
		
		<option value="//api/name/bindToPort:error:">- bindToPort:error:</option>
		
		<option value="//api/name/bindToPort:interface:error:">- bindToPort:interface:error:</option>
		
		<option value="//api/name/connectToAddress:error:">- connectToAddress:error:</option>
		
		<option value="//api/name/connectToHost:onPort:error:">- connectToHost:onPort:error:</option>
		
		<option value="//api/name/connectedAddress">- connectedAddress</option>
		
		<option value="//api/name/convertIntefaceDescription:port:intoAddress4:address6:">- convertIntefaceDescription:port:intoAddress4:address6:</option>
		
		<option value="//api/name/convertNumericHost:port:intoAddress4:address6:">- convertNumericHost:port:intoAddress4:address6:</option>
		
		<option value="//api/name/doPreSend">- doPreSend</option>
		
		<option value="//api/name/doSend">- doSend</option>
		
		<option value="//api/name/doSendTimeout">- doSendTimeout</option>
		
		<option value="//api/name/enableBroadcast:error:">- enableBroadcast:error:</option>
		
		<option value="//api/name/enableReusePort:error:">- enableReusePort:error:</option>
		
		<option value="//api/name/endCurrentSend">- endCurrentSend</option>
		
		<option value="//api/name/getAddress:error:fromAddresses:">- getAddress:error:fromAddresses:</option>
		
		<option value="//api/name/init">- init</option>
		
		<option value="//api/name/isClosed">- isClosed</option>
		
		<option value="//api/name/isConnected">- isConnected</option>
		
		<option value="//api/name/isIPv4">- isIPv4</option>
		
		<option value="//api/name/isIPv4Enabled">- isIPv4Enabled</option>
		
		<option value="//api/name/isIPv6">- isIPv6</option>
		
		<option value="//api/name/joinMulticastGroup:error:">- joinMulticastGroup:error:</option>
		
		<option value="//api/name/joinMulticastGroup:onInterface:error:">- joinMulticastGroup:onInterface:error:</option>
		
		<option value="//api/name/localAddress">- localAddress</option>
		
		<option value="//api/name/markSocketQueueTargetQueue:">- markSocketQueueTargetQueue:</option>
		
		<option value="//api/name/maxReceiveIPv4BufferSize">- maxReceiveIPv4BufferSize</option>
		
		<option value="//api/name/preBind:">- preBind:</option>
		
		<option value="//api/name/preConnect:">- preConnect:</option>
		
		<option value="//api/name/sendData:toAddress:withTimeout:tag:">- sendData:toAddress:withTimeout:tag:</option>
		
		<option value="//api/name/sendData:toHost:port:withTimeout:tag:">- sendData:toHost:port:withTimeout:tag:</option>
		
		<option value="//api/name/sendData:withTimeout:tag:">- sendData:withTimeout:tag:</option>
		
		<option value="//api/name/sendTimeoutError">- sendTimeoutError</option>
		
		<option value="//api/name/setSendFilter:withQueue:">- setSendFilter:withQueue:</option>
		
		<option value="//api/name/setSendFilter:withQueue:isAsynchronous:">- setSendFilter:withQueue:isAsynchronous:</option>
		
		<option value="//api/name/setupSendTimerWithTimeout:">- setupSendTimerWithTimeout:</option>
		
		<option value="//api/name/unmarkSocketQueueTargetQueue:">- unmarkSocketQueueTargetQueue:</option>
		
		<option value="//api/name/userData">- userData</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">GCDAsyncUdpSocket Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>GCDAsyncUdpSocket.h<br />GCDAsyncUdpSocket.m</td>
</tr>
						</tbody></table></div>
					

                    

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="method-title"><code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (id)init</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>You MUST set a <a href="#//api/name/delegate">delegate</a> AND <a href="#//api/name/delegate">delegate</a> dispatch queue before attempting to
use the socket, or you will get an error.</p>

<p>The socket queue is optional.
If you pass NULL, GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will automatically create its own socket queue.
If you choose to provide a socket queue, the socket queue must not be a concurrent queue,
then please see the discussion for the method markSocketQueueTargetQueue.</p>

<p>The <a href="#//api/name/delegate">delegate</a> queue and socket queue can optionally be the same.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv4Enabled" title="isIPv4Enabled"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv4Enabled">&ndash;&nbsp;isIPv4Enabled</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>By default, both IPv4 and IPv6 are enabled.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4Enabled</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This means GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> automatically supports both protocols,
and can send to IPv4 or IPv6 addresses,
as well as receive over IPv4 and IPv6.</p>

<p>For operations that require DNS resolution, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> supports both IPv4 and IPv6.
If a DNS lookup returns only IPv4 results, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> will automatically use IPv4.
If a DNS lookup returns only IPv6 results, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> will automatically use IPv6.
If a DNS lookup returns both IPv4 and IPv6 results, then the protocol used depends on the configured preference.
If IPv4 is preferred, then IPv4 is used.
If IPv6 is preferred, then IPv6 is used.
If neutral, then the first IP version in the resolved array will be used.</p>

<p>Starting with Mac OS X 10.7 Lion and iOS 5, the default IP preference is neutral.
On prior systems the default IP preference is IPv4.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maxReceiveIPv4BufferSize" title="maxReceiveIPv4BufferSize"></a>
	<h3 class="method-title"><code><a href="#//api/name/maxReceiveIPv4BufferSize">&ndash;&nbsp;maxReceiveIPv4BufferSize</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default maximum size is 9216 bytes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (uint16_t)maxReceiveIPv4BufferSize</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.
The theoretical maximum size of any IPv6 UDP packet is UINT32_MAX = 4294967295.</p>

<p>Since the OS/GCD notifies us of the size of each received UDP packet,
the actual allocated buffer size for each packet is exact.
And in practice the size of UDP packets is generally much smaller than the max.
Indeed most protocols will send and receive packets of only a few bytes,
or will set a limit on the size of packets to prevent fragmentation in the IP layer.</p>

<p>If you set the buffer size too small, the sockets API in the OS will silently discard
any extra data, and you will not be notified of the error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/userData" title="userData"></a>
	<h3 class="method-title"><code><a href="#//api/name/userData">&ndash;&nbsp;userData</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>User data allows you to associate arbitrary information with the socket.
This data is not used internally in any way.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (id)userData</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/localAddress" title="localAddress"></a>
	<h3 class="method-title"><code><a href="#//api/name/localAddress">&ndash;&nbsp;localAddress</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the local address info for the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSData *)localAddress</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>The localAddress method returns a sockaddr structure wrapped in a NSData object.
The <a href="#//api/name/localHost">localHost</a> method returns the human readable IP address as a string.</p>

<p>Note: Address info may not be available until after the socket has been binded, connected
or until after data has been sent.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectedAddress" title="connectedAddress"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectedAddress">&ndash;&nbsp;connectedAddress</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the remote address info for the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSData *)connectedAddress</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>The connectedAddress method returns a sockaddr structure wrapped in a NSData object.
The <a href="#//api/name/connectedHost">connectedHost</a> method returns the human readable IP address as a string.</p>

<p>Note: Since UDP is connectionless by design, connected address info
will not be available unless the socket is explicitly connected to a remote host/port.
If the socket is not connected, these methods will return nil / 0.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isConnected" title="isConnected"></a>
	<h3 class="method-title"><code><a href="#//api/name/isConnected">&ndash;&nbsp;isConnected</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isConnected</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isClosed" title="isClosed"></a>
	<h3 class="method-title"><code><a href="#//api/name/isClosed">&ndash;&nbsp;isClosed</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isClosed</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket is IPv4.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>By default this will be true, unless:
- IPv4 is disabled (via setIPv4Enabled:)
- The socket is explicitly bound to an IPv6 address
- The socket is connected to an IPv6 address</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv6" title="isIPv6"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv6">&ndash;&nbsp;isIPv6</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket is IPv6.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>By default this will be true, unless:
- IPv6 is disabled (via setIPv6Enabled:)
- The socket is explicitly bound to an IPv4 address
_ The socket is connected to an IPv4 address</p>

<p>This method will also return false on platforms that do not support IPv6.
Note: The iPhone does not currently support IPv6.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bindToPort:error:" title="bindToPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/bindToPort:error:">&ndash;&nbsp;bindToPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Binds the UDP socket to the given port.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>You may optionally pass a port number of zero to immediately bind the socket,
yet still allow the OS to automatically assign an available port.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bindToPort:interface:error:" title="bindToPort:interface:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/bindToPort:interface:error:">&ndash;&nbsp;bindToPort:interface:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Binds the UDP socket to the given port and optional interface.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(uint16_t)<em>port</em> interface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>You may optionally pass a port number of zero to immediately bind the socket,
yet still allow the OS to automatically assign an available port.</p>

<p>The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that
the socket only accept packets from the local machine.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bindToAddress:error:" title="bindToAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/bindToAddress:error:">&ndash;&nbsp;bindToAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)bindToAddress:(NSData *)<em>localAddr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Choosing to connect to a specific host/port has the following effect:
- You will only be able to send data to the connected host/port.
- You will only be able to receive data from the connected host/port.
- You will receive ICMP messages that come from the connected host/port, such as &ldquo;connection refused&rdquo;.</p>

<p>The actual process of connecting a UDP socket does not result in any communication on the socket.
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after it has been connected.
You can only connect a socket once.</p>

<p>The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).</p>

<p>This method is asynchronous as it requires a DNS lookup to resolve the given host name.
If an obvious error is detected, this method immediately returns NO and sets errPtr.
If you don&rsquo;t care about the error, you can pass nil for errPtr.
Otherwise, this method returns YES and begins the asynchronous connection process.
The result of the asynchronous connection process will be reported via the delegate methods.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>By design, UDP is a connectionless protocol, and connecting is not needed.</p>

<p>Choosing to connect to a specific address has the following effect:
- You will only be able to send data to the connected address.
- You will only be able to receive data from the connected address.
- You will receive ICMP messages that come from the connected address, such as &ldquo;connection refused&rdquo;.</p>

<p>Connecting a UDP socket does not result in any communication on the socket.
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after its been connected.
You can only connect a socket once.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>

<p>Note: Unlike the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method, this method does not require a DNS lookup.
Thus when this method returns, the connection has either failed or fully completed.
In other words, this method is synchronous, unlike the asynchronous connectToHost::: method.
However, for compatibility and simplification of delegate code, if this method returns YES
then the corresponding delegate method (udpSocket:didConnectToHost:port:) is still invoked.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/joinMulticastGroup:error:" title="joinMulticastGroup:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/joinMulticastGroup:error:">&ndash;&nbsp;joinMulticastGroup:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/joinMulticastGroup:onInterface:error:" title="joinMulticastGroup:onInterface:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/joinMulticastGroup:onInterface:error:">&ndash;&nbsp;joinMulticastGroup:onInterface:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> onInterface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/enableReusePort:error:" title="enableReusePort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/enableReusePort:error:">&ndash;&nbsp;enableReusePort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>By default, only one socket can be bound to a given IP address + port at a time.
To enable multiple processes to simultaneously bind to the same address+port,
you need to enable this functionality in the socket.  All processes that wish to
use the address+port simultaneously must all enable reuse port on the socket
bound to that port.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)enableReusePort:(BOOL)<em>flag</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/enableBroadcast:error:" title="enableBroadcast:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/enableBroadcast:error:">&ndash;&nbsp;enableBroadcast:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>By default, the underlying socket in the OS will not allow you to send broadcast messages.
In order to send broadcast messages, you need to enable this functionality in the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)enableBroadcast:(BOOL)<em>flag</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>A broadcast is a UDP message to addresses like &ldquo;192.168.255.255&rdquo; or &ldquo;255.255.255.255&rdquo; that is
delivered to every host on the network.
The reason this is generally disabled by default (by the OS) is to prevent
accidental broadcast messages from flooding the network.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:withTimeout:tag:" title="sendData:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:withTimeout:tag:">&ndash;&nbsp;sendData:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method may only be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the delegate method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the delegate method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:toHost:port:withTimeout:tag:" title="sendData:toHost:port:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:toHost:port:withTimeout:tag:">&ndash;&nbsp;sendData:toHost:port:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> toHost:(NSString *)<em>host</em> port:(uint16_t)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method cannot be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param host
The destination to send the udp packet to.
May be specified as a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).
You may also use the convenience strings of &ldquo;loopback&rdquo; or &ldquo;localhost&rdquo;.</p>

<p>@param port
The port of the host to send to.</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the delegate method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the delegate method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:toAddress:withTimeout:tag:" title="sendData:toAddress:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:toAddress:withTimeout:tag:">&ndash;&nbsp;sendData:toAddress:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> toAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method cannot be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param remoteAddr
The address to send the data to (specified as a sockaddr structure wrapped in a NSData object).</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the delegate method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the delegate method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setSendFilter:withQueue:" title="setSendFilter:withQueue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setSendFilter:withQueue:">&ndash;&nbsp;setSendFilter:withQueue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<ol>
<li><p>Optional caching of resolved addresses for domain names.
The cache could later be consulted, resulting in fewer system calls to getaddrinfo.</p></li>
<li><p>Reusable modules of code for bandwidth monitoring.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.
A filter allows you to write custom code to simulate such environments.
The ability to code this yourself is especially helpful when your simulated environment
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>


<p>For more information about <a href="../Blocks/GCDAsyncUdpSocketSendFilterBlock.html">GCDAsyncUdpSocketSendFilterBlock</a>, see the documentation for its typedef.
To remove a previously set filter, invoke this method and pass a nil filterBlock and NULL filterQueue.</p>

<p>Note: This method invokes <a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">setSendFilter:withQueue:isAsynchronous:</a> (documented below),
passing YES for the isAsynchronous parameter.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setSendFilter:withQueue:isAsynchronous:" title="setSendFilter:withQueue:isAsynchronous:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">&ndash;&nbsp;setSendFilter:withQueue:isAsynchronous:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em> isAsynchronous:(BOOL)<em>isAsynchronous</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>However, there are a few situations in which synchronous operation is preferred.
Such is the case when the filter is extremely minimal and fast.
This is because dispatch_sync is faster than dispatch_async.</p>

<p>If you choose synchronous operation, be aware of possible deadlock conditions.
Since the socket queue is executing your block via dispatch_sync,
then you cannot perform any tasks which may invoke dispatch_sync on the socket queue.
For example, you can&rsquo;t query properties on the socket.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/markSocketQueueTargetQueue:" title="markSocketQueueTargetQueue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/markSocketQueueTargetQueue:">&ndash;&nbsp;markSocketQueueTargetQueue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>See header file for big discussion of this method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)markSocketQueueTargetQueue:(dispatch_queue_t)<em>socketNewTargetQueue</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/unmarkSocketQueueTargetQueue:" title="unmarkSocketQueueTargetQueue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/unmarkSocketQueueTargetQueue:">&ndash;&nbsp;unmarkSocketQueueTargetQueue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>See header file for big discussion of this method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)unmarkSocketQueueTargetQueue:(dispatch_queue_t)<em>socketOldTargetQueue</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/hostFromAddress:" title="hostFromAddress:"></a>
	<h3 class="method-title"><code><a href="#//api/name/hostFromAddress:">+&nbsp;hostFromAddress:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Extracting host/port/family information from raw address data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (NSString *)hostFromAddress:(NSData *)<em>address</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/sendTimeoutError" title="sendTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendTimeoutError">&ndash;&nbsp;sendTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard send timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)sendTimeoutError</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/asyncResolveHost:port:withCompletionBlock:" title="asyncResolveHost:port:withCompletionBlock:"></a>
	<h3 class="method-title"><code><a href="#//api/name/asyncResolveHost:port:withCompletionBlock:">&ndash;&nbsp;asyncResolveHost:port:withCompletionBlock:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method executes on a global concurrent queue.
When complete, it executes the given completion block on the socketQueue.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)asyncResolveHost:(NSString *)<em>aHost</em> port:(uint16_t)<em>port</em> withCompletionBlock:(void ( ^ ) ( NSArray *addresses , NSError *error ))<em>completionBlock</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getAddress:error:fromAddresses:" title="getAddress:error:fromAddresses:"></a>
	<h3 class="method-title"><code><a href="#//api/name/getAddress:error:fromAddresses:">&ndash;&nbsp;getAddress:error:fromAddresses:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method picks an address from the given list of addresses.
The address picked depends upon which protocols are disabled, deactived, &amp; preferred.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (int)getAddress:(NSData **)<em>addressPtr</em> error:(NSError **)<em>errorPtr</em> fromAddresses:(NSArray *)<em>addresses</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns the address family (AF_INET or AF_INET6) of the picked address,
or AF_UNSPEC and the corresponding error is there&rsquo;s a problem.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/convertIntefaceDescription:port:intoAddress4:address6:" title="convertIntefaceDescription:port:intoAddress4:address6:"></a>
	<h3 class="method-title"><code><a href="#//api/name/convertIntefaceDescription:port:intoAddress4:address6:">&ndash;&nbsp;convertIntefaceDescription:port:intoAddress4:address6:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Finds the address(es) of an interface description.
An inteface description may be an interface name (en0, en1, lo0) or corresponding IP (192.168.4.34).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)convertIntefaceDescription:(NSString *)<em>interfaceDescription</em> port:(uint16_t)<em>port</em> intoAddress4:(NSData **)<em>interfaceAddr4Ptr</em> address6:(NSData **)<em>interfaceAddr6Ptr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/convertNumericHost:port:intoAddress4:address6:" title="convertNumericHost:port:intoAddress4:address6:"></a>
	<h3 class="method-title"><code><a href="#//api/name/convertNumericHost:port:intoAddress4:address6:">&ndash;&nbsp;convertNumericHost:port:intoAddress4:address6:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Converts a numeric hostname into its corresponding address.
The hostname is expected to be an IPv4 or IPv6 address represented as a human-readable string. (e.g. 192.168.4.34)</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)convertNumericHost:(NSString *)<em>numericHost</em> port:(uint16_t)<em>port</em> intoAddress4:(NSData **)<em>addr4Ptr</em> address6:(NSData **)<em>addr6Ptr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/preBind:" title="preBind:"></a>
	<h3 class="method-title"><code><a href="#//api/name/preBind:">&ndash;&nbsp;preBind:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method runs through the various checks required prior to a bind attempt.
It is shared between the various bind methods.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)preBind:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/preConnect:" title="preConnect:"></a>
	<h3 class="method-title"><code><a href="#//api/name/preConnect:">&ndash;&nbsp;preConnect:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method runs through the various checks required prior to a connect attempt.
It is shared between the various connect methods.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)preConnect:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doPreSend" title="doPreSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/doPreSend">&ndash;&nbsp;doPreSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is called after a sendPacket has been dequeued.
It performs various preprocessing checks on the packet,
and queries the sendFilter (if set) to determine if the packet can be sent.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doPreSend</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>If the packet passes all checks, it will be passed on to the <a href="#//api/name/doSend">doSend</a> method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doSend" title="doSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/doSend">&ndash;&nbsp;doSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method performs the actual sending of data in the currentSend packet.
It should only be called if the</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doSend</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/endCurrentSend" title="endCurrentSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/endCurrentSend">&ndash;&nbsp;endCurrentSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Releases all resources associated with the currentSend.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)endCurrentSend</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doSendTimeout" title="doSendTimeout"></a>
	<h3 class="method-title"><code><a href="#//api/name/doSendTimeout">&ndash;&nbsp;doSendTimeout</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Performs the operations to timeout the current send operation, and move on.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doSendTimeout</code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setupSendTimerWithTimeout:" title="setupSendTimerWithTimeout:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setupSendTimerWithTimeout:">&ndash;&nbsp;setupSendTimerWithTimeout:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Sets up a timer that fires to timeout the current send operation.
This method should only be called once per send packet.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)setupSendTimerWithTimeout:(NSTimeInterval)<em>timeout</em></code></div>

		    
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2017 iHealth. All rights reserved. Updated: 2017-05-05</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>